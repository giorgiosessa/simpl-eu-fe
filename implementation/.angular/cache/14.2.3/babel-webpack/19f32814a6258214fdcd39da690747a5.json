{"ast":null,"code":"// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs'; // ## Constructor\n\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0; // `_graphs` contains subject, predicate, and object indexes per graph\n\n    this._graphs = Object.create(null); // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n\n    this._blankNodeIndex = 0; // Shift parameters if `quads` is not given\n\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory; // Add quads if passed\n\n    if (quads) this.addQuads(quads);\n  } // ## Public properties\n  // ### `size` returns the number of quads in the store\n\n\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null) return size; // Calculate the number of quads by counting to the deepest level\n\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n\n    for (const graphKey in graphs) for (const subjectKey in subjects = graphs[graphKey].subjects) for (const predicateKey in subject = subjects[subjectKey]) size += Object.keys(subject[predicateKey]).length;\n\n    return this._size = size;\n  } // ## Private methods\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n\n\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {}); // Setting the key to _any_ value signals the presence of the quad\n\n    const existed = (key2 in index2);\n    if (!existed) index2[key2] = null;\n    return !existed;\n  } // ### `_removeFromIndex` removes a quad from a three-layered index\n\n\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0],\n          index2 = index1[key1];\n    delete index2[key2]; // Remove intermediary index layers if they are empty\n\n    for (const key in index2) return;\n\n    delete index1[key1];\n\n    for (const key in index1) return;\n\n    delete index0[key0];\n  } // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graphId` will be the graph of the created quads.\n\n\n  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n    let tmp, index1, index2;\n    const entityKeys = this._entities;\n    const graph = termFromId(graphId, this._factory);\n    const parts = {\n      subject: null,\n      predicate: null,\n      object: null\n    }; // If a key is specified, use only that part of index 0.\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        parts[name0] = termFromId(entityKeys[value0], this._factory); // If a key is specified, use only that part of index 1.\n\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            parts[name1] = termFromId(entityKeys[value1], this._factory); // If a key is specified, use only that part of index 2, if it exists.\n\n            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n\n            for (let l = 0; l < values.length; l++) {\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n            }\n          }\n        }\n      }\n    }\n  } // ### `_loop` executes the callback on all keys of index 0\n\n\n  _loop(index0, callback) {\n    for (const key0 in index0) callback(key0);\n  } // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n\n\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n\n    if (index1 = index0[key0]) {\n      for (key1 in index1) callback(key1);\n    }\n  } // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n\n\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1]) callback(key0);\n    }\n  } // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n\n\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2) callback(key2);\n    }\n  } // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n\n\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0,\n        tmp,\n        index1,\n        index2; // If a key is specified, count only that part of index 0\n\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) key2 in index2 && count++; // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n\n    return count;\n  } // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n\n\n  _getGraphs(graph) {\n    if (!isString(graph)) return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  } // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n\n\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  } // ## Public methods\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n\n\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  } // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n\n\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph); // Find the graph that will contain the triple\n\n    let graphItem = this._graphs[graph]; // Create the graph if it doesn't exist yet\n\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      }; // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n\n      Object.freeze(graphItem);\n    } // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n\n\n    const ids = this._ids;\n    const entities = this._entities;\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n\n    const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n\n    this._addToIndex(graphItem.objects, object, subject, predicate); // The cached quad count is now invalid\n\n\n    this._size = null;\n    return changed;\n  } // ### `addQuads` adds multiple quads to the store\n\n\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n  } // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n\n\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  } // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n\n\n  has(subjectOrQuad, predicate, object, graph) {\n    if (subjectOrQuad && subjectOrQuad.subject) ({\n      subject: subjectOrQuad,\n      predicate,\n      object,\n      graph\n    } = subjectOrQuad);\n    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n  } // ### `import` adds a stream of quads to the store\n\n\n  import(stream) {\n    stream.on('data', quad => {\n      this.addQuad(quad);\n    });\n    return stream;\n  } // ### `removeQuad` removes a quad from the store if it exists\n\n\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject; // Convert terms to internal string representation\n\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph); // Find internal identifiers for all components\n    // and verify the quad exists.\n\n    const ids = this._ids,\n          graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false; // Remove it from all indexes\n\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n\n    if (this._size !== null) this._size--; // Remove the graph if it is empty\n\n    for (subject in graphItem.subjects) return true;\n\n    delete graphs[graph];\n    return true;\n  } // ### `removeQuads` removes multiple quads from the store\n\n\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.removeQuad(quads[i]);\n  } // ### `remove` removes a stream of quads from the store\n\n\n  remove(stream) {\n    stream.on('data', quad => {\n      this.removeQuad(quad);\n    });\n    return stream;\n  } // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({\n      objectMode: true\n    });\n\n    stream._read = () => {\n      for (const quad of this.readQuads(subject, predicate, object, graph)) stream.push(quad);\n\n      stream.push(null);\n    };\n\n    return this.remove(stream);\n  } // ### `deleteGraph` removes all triples with the given graph from the store\n\n\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  } // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getQuads(subject, predicate, object, graph) {\n    return [...this.readQuads(subject, predicate, object, graph)];\n  } // ### `readQuads` returns an generator of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  *readQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph),\n          ids = this._ids;\n\n    let content, subjectId, predicateId, objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) // If subject and object are given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId);else // If only subject and possibly predicate are given, the subject index will be the fastest\n            yield* this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId);\n        } else if (predicateId) // If only predicate and possibly object are given, the predicate index will be the fastest\n          yield* this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId);else if (objectId) // If only object is given, the object index will be the fastest\n          yield* this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId);else // If nothing is given, iterate subjects and predicates first\n          yield* this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId);\n      }\n    }\n  } // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  } // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph),\n          ids = this._ids;\n\n    let count = 0,\n        content,\n        subjectId,\n        predicateId,\n        objectId; // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object) // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        } else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        } else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n\n    return count;\n  } // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  } // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  } // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  some(callback, subject, predicate, object, graph) {\n    for (const quad of this.readQuads(subject, predicate, object, graph)) if (callback(quad)) return true;\n\n    return false;\n  } // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => {\n      results.push(s);\n    }, predicate, object, graph);\n    return results;\n  } // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId) // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        } else if (objectId) // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);else // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  } // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => {\n      results.push(p);\n    }, subject, object, graph);\n    return results;\n  } // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId) // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);else // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        } else if (objectId) // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);else // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  } // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => {\n      results.push(o);\n    }, subject, predicate, graph);\n    return results;\n  } // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids,\n          graphs = this._getGraphs(graph);\n\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback); // Translate IRIs to internal index keys.\n\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId) // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        } else if (predicateId) // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);else // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  } // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => {\n      results.push(g);\n    }, subject, predicate, object);\n    return results;\n  } // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n\n\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  } // ### `createBlankNode` creates a new blank node, returning its name\n\n\n  createBlankNode(suggestedName) {\n    let name, index; // Generate a name based on the suggested name\n\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n\n      while (this._ids[name]) name = suggestedName + index++;\n    } // Generate a generic blank node name\n    else {\n      do {\n        name = `_:b${this._blankNodeIndex++}`;\n      } while (this._ids[name]);\n    } // Add the blank node to the entities, avoiding the generation of duplicates\n\n\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  } // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n\n\n  extractLists({\n    remove = false,\n    ignoreErrors = false\n  } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n\n    const onError = ignoreErrors ? () => true : (node, message) => {\n      throw new Error(`${node.value} ${message}`);\n    }; // Traverse each list from its tail\n\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = []; // the members found as objects of rdf:first quads\n\n      let malformed = false; // signals whether the current list is malformed\n\n      let head; // the head of the list (_:b1 in above example)\n\n      let headPos; // set to subject or object when head is set\n\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n      // Traverse the list from tail to end\n\n      let current = tailQuad.subject;\n\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad,\n            first = null,\n            rest = null,\n            parent = null; // Find the first and rest of this list node\n\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out'); // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);\n          } // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);\n          } // alien triple\n          else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n\n            headPos = 'subject';\n          }\n        } // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n\n\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head) malformed = onError(current, 'can\\'t have coreferences'); // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;\n          } else {\n            head = quad; // e.g. { :s :p (1 2) }\n\n            headPos = 'object';\n          }\n        } // Store the list item and continue with parent\n\n\n        if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);\n        current = parent && parent.subject;\n      } // Don't remove any quads if the list is malformed\n\n\n      if (malformed) remove = false; // Store the list under the value of its head\n      else if (head) lists[head[headPos].value] = items;\n    }); // Remove list quads if requested\n\n    if (remove) this.removeQuads(toRemove);\n    return lists;\n  } // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n\n\n  *[Symbol.iterator]() {\n    yield* this.readQuads();\n  }\n\n} // Determines whether the argument is a string\n\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n/**\n * A class that implements both DatasetCore and Readable.\n */\n\n\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({\n      objectMode: true\n    });\n    Object.assign(this, {\n      n3Store,\n      subject,\n      predicate,\n      object,\n      graph\n    });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const {\n        n3Store,\n        graph,\n        object,\n        predicate,\n        subject\n      } = this;\n      const newStore = this._filtered = new N3Store({\n        factory: n3Store._factory\n      });\n\n      for (const quad of n3Store.readQuads(subject, predicate, object, graph)) newStore.addQuad(quad);\n    }\n\n    return this._filtered;\n  }\n\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read() {\n    for (const quad of this) this.push(quad);\n\n    this.push(null);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}
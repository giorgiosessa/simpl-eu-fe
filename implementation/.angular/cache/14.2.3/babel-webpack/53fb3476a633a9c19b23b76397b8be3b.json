{"ast":null,"code":"// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'readable-stream'; // ## Constructor\n\nexport default class N3StreamParser extends Transform {\n  constructor(options) {\n    super({\n      decodeStrings: true\n    });\n    this._readableState.objectMode = true; // Set up parser with dummy stream to obtain `data` and `end` callbacks\n\n    const parser = new N3Parser(options);\n    let onData, onEnd;\n    parser.parse({\n      on: (event, callback) => {\n        switch (event) {\n          case 'data':\n            onData = callback;\n            break;\n\n          case 'end':\n            onEnd = callback;\n            break;\n        }\n      }\n    }, // Handle quads by pushing them down the pipeline\n    (error, quad) => {\n      error && this.emit('error', error) || quad && this.push(quad);\n    }, // Emit prefixes through the `prefix` event\n    (prefix, uri) => {\n      this.emit('prefix', prefix, uri);\n    }); // Implement Transform methods through parser callbacks\n\n    this._transform = (chunk, encoding, done) => {\n      onData(chunk);\n      done();\n    };\n\n    this._flush = done => {\n      onEnd();\n      done();\n    };\n  } // ### Parses a stream of strings\n\n\n  import(stream) {\n    stream.on('data', chunk => {\n      this.write(chunk);\n    });\n    stream.on('end', () => {\n      this.end();\n    });\n    stream.on('error', error => {\n      this.emit('error', error);\n    });\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}
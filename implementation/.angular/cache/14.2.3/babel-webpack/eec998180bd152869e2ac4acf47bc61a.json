{"ast":null,"code":"// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\nconst {\n  rdf,\n  xsd\n} = namespaces; // Characters in literals that require escaping\n\nconst escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n      escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n      escapedCharacters = {\n  '\\\\': '\\\\\\\\',\n  '\"': '\\\\\"',\n  '\\t': '\\\\t',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f'\n}; // ## Placeholder class to represent already pretty-printed terms\n\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n\n} // ## Constructor\n\n\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/; // Shift arguments if the first argument is not a stream\n\n    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists; // If no output stream given, send the output as string through the end callback\n\n    if (!outputStream) {\n      let output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) {\n          output += chunk;\n          done && done();\n        },\n\n        end: done => {\n          done && done(null, output);\n        }\n      };\n      this._endStream = true;\n    } else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    } // Initialize writer, depending on the format\n\n\n    this._subject = null;\n\n    if (!/triple|quad/i.test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n\n      if (options.baseIRI) {\n        this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)}${options.baseIRI.endsWith('/') ? '' : '[#?]'}`);\n        this._baseLength = options.baseIRI.length;\n      }\n    } else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  } // ## Private methods\n  // ### Whether the current graph is the default graph\n\n\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  } // ### `_write` writes the argument to the output stream\n\n\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  } // ### `_writeQuad` writes the quad to the output stream\n\n\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\\n' : '\\n}\\n') + (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n\n        this._graph = graph;\n        this._subject = null;\n      } // Don't repeat the subject if it's the same\n\n\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate)) this._write(`, ${this._encodeObject(object)}`, done); // Same subject, different predicate\n        else this._write(`;\\n    ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n      } // Different subject; write the whole quad\n      else this._write(`${(this._subject === null ? '' : '.\\n') + this._encodeSubject(this._subject = subject)} ${this._encodePredicate(this._predicate = predicate)} ${this._encodeObject(object)}`, done);\n    } catch (error) {\n      done && done(error);\n    }\n  } // ### `_writeQuadLine` writes the quad to the output stream as a single line\n\n\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  } // ### `quadToString` serializes a quad as a string\n\n\n  quadToString(subject, predicate, object, graph) {\n    return `${this._encodeSubject(subject)} ${this._encodeIriOrBlank(predicate)} ${this._encodeObject(object)}${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n  } // ### `quadsToString` serializes an array of quads as a string\n\n\n  quadsToString(quads) {\n    return quads.map(t => {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }).join('');\n  } // ### `_encodeSubject` represents a subject\n\n\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  } // ### `_encodeIriOrBlank` represents an IRI or blank node\n\n\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : `_:${entity.value}`;\n    }\n\n    let iri = entity.value; // Use relative IRIs if requested and possible\n\n    if (this._baseMatcher && this._baseMatcher.test(iri)) iri = iri.substr(this._baseLength); // Escape special characters\n\n    if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer); // Try to represent the IRI as prefixed name\n\n    const prefixMatch = this._prefixRegex.exec(iri);\n\n    return !prefixMatch ? `<${iri}>` : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n  } // ### `_encodeLiteral` represents a literal\n\n\n  _encodeLiteral(literal) {\n    // Escape special characters\n    let value = literal.value;\n    if (escape.test(value)) value = value.replace(escapeAll, characterReplacer); // Write a language-tagged literal\n\n    if (literal.language) return `\"${value}\"@${literal.language}`; // Write dedicated literals per data type\n\n    if (this._lineMode) {\n      // Only abbreviate strings in N-Triples or N-Quads\n      if (literal.datatype.value === xsd.string) return `\"${value}\"`;\n    } else {\n      // Use common datatype abbreviations in Turtle or TriG\n      switch (literal.datatype.value) {\n        case xsd.string:\n          return `\"${value}\"`;\n\n        case xsd.boolean:\n          if (value === 'true' || value === 'false') return value;\n          break;\n\n        case xsd.integer:\n          if (/^[+-]?\\d+$/.test(value)) return value;\n          break;\n\n        case xsd.decimal:\n          if (/^[+-]?\\d*\\.\\d+$/.test(value)) return value;\n          break;\n\n        case xsd.double:\n          if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value)) return value;\n          break;\n      }\n    } // Write a regular datatyped literal\n\n\n    return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n  } // ### `_encodePredicate` represents a predicate\n\n\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  } // ### `_encodeObject` represents an object\n\n\n  _encodeObject(object) {\n    switch (object.termType) {\n      case 'Quad':\n        return this._encodeQuad(object);\n\n      case 'Literal':\n        return this._encodeLiteral(object);\n\n      default:\n        return this._encodeIriOrBlank(object);\n    }\n  } // ### `_encodeQuad` encodes an RDF* quad\n\n\n  _encodeQuad({\n    subject,\n    predicate,\n    object,\n    graph\n  }) {\n    return `<<${this._encodeSubject(subject)} ${this._encodePredicate(predicate)} ${this._encodeObject(object)}${isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  } // ### `_blockedWrite` replaces `_write` after the writer has been closed\n\n\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  } // ### `addQuad` adds the quad to the output stream\n\n\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate); // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph); // The `graph` parameter was provided\n    else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  } // ### `addQuads` adds the quads to the output stream\n\n\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n  } // ### `addPrefix` adds the prefix to the output stream\n\n\n  addPrefix(prefix, iri, done) {\n    const prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  } // ### `addPrefixes` adds the prefixes to the output stream\n\n\n  addPrefixes(prefixes, done) {\n    // Ignore prefixes if not supported by the serialization\n    if (!this._prefixIRIs) return done && done(); // Write all new prefixes\n\n    let hasPrefixes = false;\n\n    for (let prefix in prefixes) {\n      let iri = prefixes[prefix];\n      if (typeof iri !== 'string') iri = iri.value;\n      hasPrefixes = true; // Finish a possible pending quad\n\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n        this._subject = null, this._graph = '';\n      } // Store and write the prefix\n\n\n      this._prefixIRIs[iri] = prefix += ':';\n\n      this._write(`@prefix ${prefix} <${iri}>.\\n`);\n    } // Recreate the prefix matcher\n\n\n    if (hasPrefixes) {\n      let IRIlist = '',\n          prefixList = '';\n\n      for (const prefixIRI in this._prefixIRIs) {\n        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n      }\n\n      IRIlist = escapeRegex(IRIlist, /[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` + `^(${IRIlist})([a-zA-Z][\\\\-_a-zA-Z0-9]*)$`);\n    } // End a prefix block with a newline\n\n\n    this._write(hasPrefixes ? '\\n' : '', done);\n  } // ### `blank` creates a blank node with the given content\n\n\n  blank(predicate, object) {\n    let children = predicate,\n        child,\n        length; // Empty blank node\n\n    if (predicate === undefined) children = []; // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType) children = [{\n      predicate: predicate,\n      object: object\n    }]; // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate)) children = [predicate];\n\n    switch (length = children.length) {\n      // Generate an empty blank node\n      case 0:\n        return new SerializedTerm('[]');\n      // Generate a non-nested one-triple blank node\n\n      case 1:\n        child = children[0];\n        if (!(child.object instanceof SerializedTerm)) return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)} ]`);\n      // Generate a multi-triple or nested blank node\n\n      default:\n        let contents = '['; // Write all triples in order\n\n        for (let i = 0; i < length; i++) {\n          child = children[i]; // Write only the object is the predicate is the same as the previous\n\n          if (child.predicate.equals(predicate)) contents += `, ${this._encodeObject(child.object)}`; // Otherwise, write the predicate and the object\n          else {\n            contents += `${(i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate)} ${this._encodeObject(child.object)}`;\n            predicate = child.predicate;\n          }\n        }\n\n        return new SerializedTerm(`${contents}\\n]`);\n    }\n  } // ### `list` creates a list node with the given content\n\n\n  list(elements) {\n    const length = elements && elements.length || 0,\n          contents = new Array(length);\n\n    for (let i = 0; i < length; i++) contents[i] = this._encodeObject(elements[i]);\n\n    return new SerializedTerm(`(${contents.join(' ')})`);\n  } // ### `end` signals the end of the output stream\n\n\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n\n      this._subject = null;\n    } // Disallow further writing\n\n\n    this._write = this._blockedWrite; // Try to end the underlying stream, ensuring done is called exactly one time\n\n    let singleDone = done && ((error, result) => {\n      singleDone = null, done(error, result);\n    });\n\n    if (this._endStream) {\n      try {\n        return this._outputStream.end(singleDone);\n      } catch (error) {\n        /* error closing stream */\n      }\n    }\n\n    singleDone && singleDone();\n  }\n\n} // Replaces a character by its escaped version\n\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  let result = escapedCharacters[character];\n\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    } // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n\n  return result;\n}\n\nfunction escapeRegex(regex) {\n  return regex.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n}","map":null,"metadata":{},"sourceType":"module"}
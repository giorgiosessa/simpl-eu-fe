{"ast":null,"code":"import { FormArray, FormControl, FormGroup } from '@angular/forms';\nimport { FormField } from '@models/form-field.model';\nimport { Prefix, ShaclFile } from '@models/shacl-file';\nimport { Shape } from '@models/shape';\nimport { Utils } from '@shared/utils';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@services/validation.service\";\nimport * as i2 from \"@services/api.service\";\nexport let FormfieldControlService = /*#__PURE__*/(() => {\n  class FormfieldControlService {\n    constructor(validationService, apiService) {\n      this.validationService = validationService;\n      this.apiService = apiService;\n    }\n\n    readShaclFile(data) {\n      // Create a shacl file object\n      const file = new ShaclFile();\n\n      if (data === undefined) {\n        data = this.apiService.getFieldsFromFile();\n      }\n\n      file.shapes = this.getShapes(data.shapes);\n      file.prefixes = this.getPrefixes(data.prefixList);\n      return file;\n    }\n\n    getShapes(shapes) {\n      // Create an array (FormFieldsGroups) for all shapes\n      const formFieldsShapes = [];\n      Array.prototype.forEach.call(shapes, shapesGroup => {\n        const formFieldShape = new Shape({\n          schema: shapesGroup.schema,\n          prefix: shapesGroup.targetClassPrefix,\n          name: shapesGroup.targetClassName\n        }); // Get the constraints for each shape\n\n        const constraints = shapesGroup.constraints;\n\n        if (constraints !== undefined && constraints.length > 0) {\n          // Each form field group has an array of form fields\n          const formFields = [];\n          constraints.forEach(field => {\n            // Create a form field object and get the main properties\n            const formField = new FormField({\n              key: field.path.value,\n              name: field.name === undefined ? field.path.value : field.name,\n              prefix: field.path.prefix,\n              datatype: field.datatype,\n              minCount: field.minCount,\n              required: field.minCount >= 1,\n              maxCount: field.maxCount,\n              order: field.order,\n              group: field.group,\n              in: field.in,\n              or: field.or !== undefined ? field.or : [],\n              validations: field.validations,\n              childrenSchema: field.children,\n              description: field.description\n            }); // Get control type\n\n            formField.controlTypes = this.getControlTypes(formField); // Get the component type\n\n            formField.componentType = this.getComponentType(formField); // Get the group property\n\n            formField.group = this.getGroupProperty(formField); // Add the datatype\n\n            formField.datatype = this.getDataType(formField);\n            formFields.push(formField);\n          });\n          formFieldShape.fields = formFields.sort((a, b) => a.order - b.order);\n          formFieldShape.toolTipText = formFields.map(x => x.name).toString();\n          formFieldsShapes.push(formFieldShape);\n        }\n      });\n      return this.getChildrenFields(formFieldsShapes);\n    }\n\n    getChildrenFields(formFieldsShapes) {\n      const shapes = formFieldsShapes;\n      formFieldsShapes.forEach(shape => shape.fields.forEach(field => {\n        if (field.childrenSchema !== '') {\n          const childrenShape = formFieldsShapes.find(x => x.schema === field.childrenSchema || x.name === field.childrenSchema);\n\n          if (childrenShape !== undefined) {\n            if (shape === childrenShape) // self-loops scenario\n              {\n                field.selfLoop = true;\n                field.componentType = 'dynamicSelfLoop';\n              } else {\n              field.childrenFields = this.updateChildrenFieldsIds(childrenShape.fields);\n              childrenShape.parentSchema = shape.schema;\n            }\n          }\n        }\n      }));\n      return shapes;\n    }\n\n    updateChildrenFieldsIds(fields) {\n      const updatedFormFields = [];\n      fields.forEach(field => {\n        const tempField = Object.assign({}, field);\n        tempField.id = Utils.getRandomValue();\n        updatedFormFields.push(tempField);\n      });\n      return updatedFormFields;\n    }\n\n    getPrefixes(prefixesList) {\n      // Create an array (FormFieldsGroups) for all shapes\n      const prefixes = [];\n      Array.prototype.forEach.call(prefixesList, prefix => {\n        const prefixObject = new Prefix(prefix.alias, prefix.url);\n        prefixes.push(prefixObject);\n      });\n      return prefixes;\n    }\n\n    getFormFields(constraints) {\n      const formFields = [];\n      constraints === null || constraints === void 0 ? void 0 : constraints.forEach(field => {\n        const formField = new FormField({\n          key: field['path'],\n          name: field['name'] === undefined ? field['path'] : field['name'],\n          datatype: field['datatype'],\n          required: field['minCount'] >= 1,\n          minCount: field['minCount'],\n          maxCount: field['maxCount'],\n          order: field['order'],\n          group: field['group'],\n          controlTypes: this.getControlTypes(field),\n          in: field['in'],\n          or: field['or'] !== undefined ? field['or']['values'] : [],\n          validations: field['validations']\n        });\n        formField.componentType = this.getComponentType(formField);\n        formFields.push(formField);\n      });\n      return formFields.sort((a, b) => a.order - b.order);\n    } // Convert form field model array in form group\n\n\n    toFormGroup(inputs = []) {\n      return new FormGroup(this.toGroup(inputs));\n    } // Recursive function to convert input form field into form controls\n\n\n    toGroup(inputs = [], group = {}) {\n      inputs === null || inputs === void 0 ? void 0 : inputs.forEach(input => {\n        const validator = this.validationService.getValidatorFn(input);\n\n        if (input.componentType === 'dynamicExpanded' && !input.selfLoop) {\n          let nestedForm;\n          nestedForm = this.toGroup(input.childrenFields, nestedForm);\n          const nestedFormGroup = new FormGroup(nestedForm, validator);\n          group[input.id] = nestedFormGroup;\n        } else {\n          group[input.id] = validator.length > 0 ? new FormControl(input.value || null, validator) : new FormControl(input.value || null);\n\n          if (input.componentType === 'dynamicFormArray') {\n            group[input.id] = new FormArray([group[input.id]]);\n          }\n        }\n      });\n      return group;\n    }\n\n    selfLooptoGroup(input, group = {}) {\n      const validator = this.validationService.getValidatorFn(input);\n      let nestedForm;\n      nestedForm = this.toGroup(input.childrenFields, nestedForm);\n      const nestedFormGroup = new FormGroup(nestedForm, validator);\n      group[input.id] = nestedFormGroup;\n      return group;\n    }\n\n    getControlTypes(field) {\n      var _a;\n\n      const controlTypes = [];\n      const orProperty = field.or;\n\n      if (field.in !== undefined && field.in.length > 0) {\n        if (field.in[0].prefix === undefined) {\n          controlTypes.push('dropdown');\n        } else {\n          controlTypes.push('dropdown_object');\n        }\n      } else if (field.or !== undefined && field.or.length > 0) {\n        orProperty.forEach(element => {\n          if (element['datatype'] !== undefined) {\n            controlTypes.push(this.getSingleControlType(element['datatype'].value));\n          }\n        });\n      } else if (field.childrenSchema === '') {\n        controlTypes.push(this.getSingleControlType((_a = field.datatype) === null || _a === void 0 ? void 0 : _a.value));\n      }\n\n      return controlTypes;\n    }\n\n    getSingleControlType(fieldType) {\n      let controlType = '';\n\n      switch (fieldType) {\n        case 'date':\n          controlType = 'datepicker';\n          break;\n\n        case 'dateTime':\n        case 'dateTimeStamp':\n          controlType = 'datetimepicker';\n          break;\n\n        case 'integer':\n          controlType = 'textbox_integer';\n          break;\n\n        case 'decimal':\n          controlType = 'textbox_decimal';\n          break;\n\n        case 'anyURI':\n          controlType = 'textbox_uri';\n          break;\n\n        case 'boolean':\n          controlType = 'checkbox';\n          break;\n\n        default:\n          controlType = 'textbox';\n          break;\n      }\n\n      return controlType;\n    }\n\n    getDataType(field) {\n      let datatype = field.datatype; // Add default datatype when datatype is undefinded\n\n      if (field.datatype === undefined) {\n        datatype = {\n          prefix: 'xsd',\n          value: 'string'\n        };\n      } // In case of a or a property, add the datatype of the first option\n\n\n      if (field.or !== undefined && field.or.length > 0) {\n        datatype = field.or[0]['datatype'];\n      }\n\n      return datatype;\n    } // Decide the component type (input, array, or) based on the values of maxCount, minCount and control types\n\n\n    getComponentType(field) {\n      var _a;\n\n      let componentType = '';\n\n      if (field.controlTypes.length === 1) {\n        if ((field.minCount === 0 || field.minCount === 1) && field.maxCount === 1 || ((_a = field.datatype) === null || _a === void 0 ? void 0 : _a.value) === 'boolean') {\n          componentType = 'dynamicFormInput';\n        } else {\n          componentType = 'dynamicFormArray';\n        }\n      } else if (field.childrenSchema !== '') {\n        componentType = 'dynamicExpanded';\n      } else if (field.or !== undefined && field.or.length > 0) {\n        if ((field.minCount === 0 || field.minCount === 1) && field.maxCount === 1) {\n          componentType = 'dynamicFormOr';\n        } else {\n          componentType = 'dynamicFormOrArray';\n        }\n      }\n\n      return componentType;\n    }\n\n    getGroupProperty(formField) {\n      let group = '';\n      const validations = formField['validations'];\n\n      if (validations !== undefined) {\n        const groupProperty = validations.find(x => x.key === 'group');\n\n        if (groupProperty !== undefined) {\n          group = groupProperty.value;\n        }\n      }\n\n      return group;\n    }\n\n    fieldHasNodeKindProperty(formField) {\n      const result = formField.datatype !== undefined && formField.datatype.prefix === 'nodeKind' && formField.datatype.value === 'IRI';\n      return result;\n    }\n\n    updateFilteredShapes(shaclFile) {\n      let filteredShapes = shaclFile === null || shaclFile === void 0 ? void 0 : shaclFile.shapes; // Not dispay shapes that are part of the or and in array\n\n      if (filteredShapes) {\n        filteredShapes.forEach(shape => {\n          const toRemoveOr = this.getOrPropertyShapeNames(shape.fields, []);\n          filteredShapes = filteredShapes.filter(el => {\n            return toRemoveOr.indexOf(el.name) < 0;\n          });\n          const toRemoveIn = this.getInPropertyShapeNames(shape.fields, []);\n          filteredShapes = filteredShapes.filter(el => {\n            return toRemoveIn.indexOf(el.name) < 0;\n          });\n        }); // Not display nested shapes\n\n        filteredShapes = filteredShapes.filter(x => x.parentSchema == null);\n      }\n\n      return filteredShapes;\n    }\n\n    getOrPropertyShapeNames(fields, result) {\n      fields.forEach(field => {\n        if (field.childrenSchema === '') {\n          if (field.or !== undefined && field.or.length > 1) {\n            field.or.forEach(object => {\n              if (object['clazz'] !== undefined) {\n                result.push(object['clazz'].value);\n              }\n\n              if (object['datatype'] !== undefined) {\n                result.push(object['datatype'].value);\n              }\n            });\n          }\n        } else {\n          this.getOrPropertyShapeNames(field.childrenFields, result);\n        }\n      });\n      return result;\n    }\n\n    getInPropertyShapeNames(fields, result) {\n      fields.forEach(field => {\n        if (field.childrenSchema === '') {\n          if (field.in !== undefined && field.in.length > 1) {\n            field.in.forEach(object => {\n              if (object !== undefined) {\n                result.push(object.value);\n              }\n            });\n          }\n        } else {\n          this.getOrPropertyShapeNames(field.childrenFields, result);\n        }\n      });\n      return result;\n    }\n\n  }\n\n  FormfieldControlService.ɵfac = function FormfieldControlService_Factory(t) {\n    return new (t || FormfieldControlService)(i0.ɵɵinject(i1.ValidationControlService), i0.ɵɵinject(i2.ApiService));\n  };\n\n  FormfieldControlService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FormfieldControlService,\n    factory: FormfieldControlService.ɵfac,\n    providedIn: 'root'\n  });\n  return FormfieldControlService;\n})();","map":null,"metadata":{},"sourceType":"module"}
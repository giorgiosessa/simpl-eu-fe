{"ast":null,"code":"import { saveAs } from 'file-saver';\nimport { Utils } from '@shared/utils';\nimport { DownloadFormat } from '@shared/download-format.enum';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./form-field.service\";\nexport let ExportService = /*#__PURE__*/(() => {\n  class ExportService {\n    constructor(formFieldService) {\n      this.formFieldService = formFieldService;\n    }\n\n    createRDFStream(file) {\n      const N3 = require('n3');\n\n      const {\n        DataFactory\n      } = N3;\n      const {\n        namedNode,\n        literal,\n        quad\n      } = DataFactory;\n      const selectedShape = file.shapes.find(shape => shape.selected); //const identifier = this.generateIdentifier(selectedShape);\n\n      const identifier = selectedShape.userPrefix;\n      const subject = this.getSubject(selectedShape);\n      let writer = new N3.Writer({\n        prefixes: this.getPrefixes(file.prefixes)\n      });\n      writer.addQuad(namedNode(identifier), namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode(subject));\n      selectedShape.fields.forEach(field => {\n        // Add quads for main shape\n        if (field.childrenSchema === '') {\n          field.values.forEach(val => {\n            if (this.checkValue(val)) {\n              const myQuad = quad(namedNode(identifier), namedNode(this.getPrefix(field, file.prefixes)), this.formFieldService.fieldHasNodeKindProperty(field) ? namedNode(val) : literal(val === null ? '' : val, namedNode(this.getFieldDataTypePrefix(field))));\n              writer.addQuad(myQuad);\n            }\n          });\n        } else {\n          // Update the writer variable with the writer of all nested shapes\n          writer = this.addNestedShape(file, field, identifier, writer);\n        }\n      });\n      let final;\n      writer.end((error, result) => final = result);\n      return final;\n    }\n\n    addNestedShape(file, formField, identifier, writer) {\n      const N3 = require('n3');\n\n      const {\n        DataFactory\n      } = N3;\n      const {\n        namedNode,\n        quad\n      } = DataFactory;\n      const myQuad = quad(namedNode(identifier), namedNode(this.getPrefix(formField, file.prefixes)), writer.blank(this.addNestedShapeFields(file, formField, identifier, writer)));\n      writer.addQuad(myQuad);\n      return writer;\n    }\n\n    addNestedShapeFields(file, formField, identifier, writer) {\n      const N3 = require('n3');\n\n      const {\n        DataFactory\n      } = N3;\n      const {\n        namedNode,\n        literal,\n        quad\n      } = DataFactory;\n      const quads = [];\n      const obj = {};\n      const childrenShape = file.shapes.find(x => x.schema === formField.childrenSchema); // Declare is-a relationship\n\n      obj['predicate'] = namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');\n      obj['object'] = namedNode(this.getSubject(childrenShape));\n      quads.push(obj); // Iterate over children fields, if the field does not have child, then for each value add the predicate and object\n      // Otherwise, first add the nested shape and come over again (recursively) to add the fields\n\n      formField.childrenFields.forEach(field => {\n        if (field.childrenSchema === '') {\n          field.values.forEach(value => {\n            if (this.checkValue(value)) {\n              const values = {};\n              values['predicate'] = namedNode(this.getPrefix(field, file.prefixes));\n              values['object'] = this.formFieldService.fieldHasNodeKindProperty(field) ? namedNode(value) : literal(value === null ? '' : value, namedNode(this.getFieldDataTypePrefix(field)));\n              quads.push(values);\n            }\n          });\n        } else {\n          const myQuad = quad(namedNode(identifier), namedNode(this.getPrefix(field, file.prefixes)), writer.blank(this.addNestedShapeFields(file, field, identifier, writer)));\n          quads.push(myQuad);\n        }\n      });\n      return quads;\n    }\n\n    getPrefixes(prefixes) {\n      const obj = {};\n      prefixes.forEach(prefix => {\n        const key = prefix.alias;\n        const value = prefix.url;\n        obj[key] = value;\n      });\n      return obj;\n    }\n\n    generateIdentifier(shape) {\n      let url = 'http://example.org/';\n\n      if (shape.userPrefix && shape.userPrefix !== '') {\n        url = this.getValidatedPrefix(shape.userPrefix);\n      }\n\n      const random = Utils.getRandomValue();\n      const identifier = shape.name;\n      return identifier;\n    }\n\n    getValidatedPrefix(prefix) {\n      let result = '';\n\n      if (prefix.endsWith('#') || prefix.endsWith('/')) {\n        result = prefix;\n      } else {\n        result = prefix.concat('/');\n      }\n\n      return result;\n    }\n\n    getSubject(shape) {\n      if (shape) {\n        return shape.prefix.concat(':').concat(shape.name);\n      }\n    }\n\n    getFieldDataTypePrefix(formField) {\n      let datatypePrefix = ''; // In case of dropdown we do not have a specified datatype\n\n      if (formField.in.length === 0 && formField.datatype.prefix !== undefined) {\n        datatypePrefix = formField.datatype.prefix.concat(':').concat(formField.datatype.value);\n      }\n\n      return datatypePrefix;\n    }\n\n    getPrefix(formField, prefixes) {\n      const prefixField = formField.prefix;\n      const prefixURL = prefixes.find(x => x.alias === prefixField);\n\n      if (prefixURL !== undefined) {\n        return prefixURL.url.concat(formField.key);\n      }\n\n      return '';\n    }\n\n    checkValue(val) {\n      let valid = false;\n\n      if (Array.isArray(val)) {\n        if (val[0] !== null) {\n          valid = true;\n        }\n      } else if (val !== null && val !== '') {\n        valid = true;\n      }\n\n      return valid;\n    }\n\n    saveFile(file) {\n      const rdfStream = this.createRDFStream(file);\n      const selectedShape = file.shapes.find(shape => shape.selected); // check for download format\n\n      let blob;\n      let fileName;\n\n      if (selectedShape.downloadFormat === DownloadFormat.turtle) {\n        blob = new Blob([rdfStream], {\n          type: 'turtle'\n        });\n        fileName = selectedShape.name.concat('-instance.ttl');\n      } else if (selectedShape.downloadFormat === DownloadFormat.jsonld) {\n        blob = new Blob([this.convertTurtleToJsonLd(`${rdfStream}`)], {\n          type: 'application/json'\n        });\n        fileName = selectedShape.name.concat('-instance.json');\n      }\n\n      saveAs(blob, fileName);\n    }\n\n    convertTurtleToJsonLd(ttl) {\n      const ttl2jsonld = require('@frogcat/ttl2jsonld').parse;\n\n      const jsonld = JSON.stringify(ttl2jsonld(ttl), null, 2);\n      debugger;\n      return jsonld;\n    }\n\n  }\n\n  ExportService.ɵfac = function ExportService_Factory(t) {\n    return new (t || ExportService)(i0.ɵɵinject(i1.FormfieldControlService));\n  };\n\n  ExportService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ExportService,\n    factory: ExportService.ɵfac,\n    providedIn: 'root'\n  });\n  return ExportService;\n})();","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nconst {\n  rdf,\n  xsd\n} = namespaces; // eslint-disable-next-line prefer-const\n\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nconst quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/; // ## DataFactory singleton\n\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad\n};\nexport default DataFactory; // ## Term constructor\n\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  } // ### The value of this term\n\n\n  get value() {\n    return this.id;\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term) return this.id === other.id; // Otherwise, compare term type and value\n\n    return !!other && this.termType === other.termType && this.value === other.value;\n  } // ### Implement hashCode for Immutable.js, since we implement `equals`\n  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()\n\n\n  hashCode() {\n    return 0;\n  } // ### Returns a plain object representation of this term\n\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value: this.value\n    };\n  }\n\n} // ## NamedNode constructor\n\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n\n} // ## Literal constructor\n\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  } // ### The text value of this literal\n\n\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  } // ### The language of this literal\n\n\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    const id = this.id;\n    let atPos = id.lastIndexOf('\"') + 1; // If \"@\" it follows, return the remaining substring; empty otherwise\n\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  } // ### The datatype IRI of this literal\n\n\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  } // ### The datatype string of this literal\n\n\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    const id = this.id,\n          dtPos = id.lastIndexOf('\"') + 1;\n    const char = dtPos < id.length ? id[dtPos] : ''; // If \"^\" it follows, return the remaining substring\n\n    return char === '^' ? id.substr(dtPos + 2) : // If \"@\" follows, return rdf:langString; xsd:string otherwise\n    char !== '@' ? xsd.string : rdf.langString;\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal) return this.id === other.id; // Otherwise, compare term type, value, language, and datatype\n\n    return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value: this.value,\n      language: this.language,\n      datatype: {\n        termType: 'NamedNode',\n        value: this.datatypeString\n      }\n    };\n  }\n\n} // ## BlankNode constructor\n\nexport class BlankNode extends Term {\n  constructor(name) {\n    super(`_:${name}`);\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'BlankNode';\n  } // ### The name of this blank node\n\n\n  get value() {\n    return this.id.substr(2);\n  }\n\n}\nexport class Variable extends Term {\n  constructor(name) {\n    super(`?${name}`);\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'Variable';\n  } // ### The name of this variable\n\n\n  get value() {\n    return this.id.substr(1);\n  }\n\n} // ## DefaultGraph constructor\n\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'DefaultGraph';\n  } // ### Returns whether this object represents the same term as the other\n\n\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return this === other || !!other && this.termType === other.termType;\n  }\n\n} // ## DefaultGraph singleton\n\nDEFAULTGRAPH = new DefaultGraph(); // ### Constructs a term from the given internal string ID\n\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory; // Falsy value or empty string indicate the default graph\n\n  if (!id) return factory.defaultGraph(); // Identify the term type based on the first character\n\n  switch (id[0]) {\n    case '?':\n      return factory.variable(id.substr(1));\n\n    case '_':\n      return factory.blankNode(id.substr(2));\n\n    case '\"':\n      // Shortcut for internal literals\n      if (factory === DataFactory) return new Literal(id); // Literal without datatype or language\n\n      if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2)); // Literal with datatype or language\n\n      const endPos = id.lastIndexOf('\"', id.length - 1);\n      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n\n    case '<':\n      const components = quadId.exec(id);\n      return factory.quad(termFromId(unescapeQuotes(components[1]), factory), termFromId(unescapeQuotes(components[2]), factory), termFromId(unescapeQuotes(components[3]), factory), components[4] && termFromId(unescapeQuotes(components[4]), factory));\n\n    default:\n      return factory.namedNode(id);\n  }\n} // ### Constructs an internal string ID from the given term or ID string\n\nexport function termToId(term) {\n  if (typeof term === 'string') return term;\n  if (term instanceof Term && term.termType !== 'Quad') return term.id;\n  if (!term) return DEFAULTGRAPH.id; // Term instantiated with another library\n\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n\n    case 'BlankNode':\n      return `_:${term.value}`;\n\n    case 'Variable':\n      return `?${term.value}`;\n\n    case 'DefaultGraph':\n      return '';\n\n    case 'Literal':\n      return `\"${term.value}\"${term.language ? `@${term.language}` : term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : ''}`;\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      return `<<${escapeQuotes(termToId(term.subject))} ${escapeQuotes(termToId(term.predicate))} ${escapeQuotes(termToId(term.object))}${isDefaultGraph(term.graph) ? '' : ` ${termToId(term.graph)}`}>>`;\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n} // ## Quad constructor\n\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this._subject = subject;\n    this._predicate = predicate;\n    this._object = object;\n    this._graph = graph || DEFAULTGRAPH;\n  } // ### The term type of this term\n\n\n  get termType() {\n    return 'Quad';\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  get predicate() {\n    return this._predicate;\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  get graph() {\n    return this._graph;\n  } // ### Returns a plain object representation of this quad\n\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      subject: this._subject.toJSON(),\n      predicate: this._predicate.toJSON(),\n      object: this._object.toJSON(),\n      graph: this._graph.toJSON()\n    };\n  } // ### Returns whether this object represents the same quad as the other\n\n\n  equals(other) {\n    return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);\n  }\n\n}\nexport { Quad as Triple }; // ### Escapes the quotes within the given literal\n\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n} // ### Unescapes the quotes within the given literal\n\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n} // ### Creates an IRI\n\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n} // ### Creates a blank node\n\n\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n} // ### Creates a literal\n\n\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string') return new Literal(`\"${value}\"@${languageOrDataType.toLowerCase()}`); // Automatically determine datatype for booleans and numbers\n\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean') datatype = xsd.boolean; // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd.double;else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  } // Create a datatyped literal\n\n\n  return datatype === '' || datatype === xsd.string ? new Literal(`\"${value}\"`) : new Literal(`\"${value}\"^^${datatype}`);\n} // ### Creates a variable\n\n\nfunction variable(name) {\n  return new Variable(name);\n} // ### Returns the default graph\n\n\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n} // ### Creates a quad\n\n\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}","map":null,"metadata":{},"sourceType":"module"}
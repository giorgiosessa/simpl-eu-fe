{"ast":null,"code":"import { DetachedRouteHandle, ActivatedRouteSnapshot } from '@angular/router';\nimport { ComponentRef } from '@angular/core';\nimport * as i0 from \"@angular/core\";\nexport let CustomRouteReuseStrategy = /*#__PURE__*/(() => {\n  class CustomRouteReuseStrategy {\n    constructor() {\n      this.handlers = {};\n    }\n\n    shouldDetach(route) {\n      return this.isDetachable(route);\n    }\n\n    store(route, handler) {\n      const storeKey = this.getStoreKey(route);\n\n      if (handler) {\n        const rootHandler = {\n          handle: handler,\n          storeTime: +new Date()\n        };\n        this.handlers[storeKey] = rootHandler;\n      }\n    }\n\n    shouldAttach(route) {\n      const storeKey = this.getStoreKey(route);\n\n      if (this.isAtachable(route, storeKey)) {\n        // retrun true only\n        // delete unnecessary stored route to save memory.\n        this.clearNewerHandlerOnAttach(this.handlers[storeKey].storeTime);\n        return true;\n      }\n\n      return false;\n    }\n\n    retrieve(route) {\n      var _a;\n\n      const storeKey = this.getStoreKey(route);\n      return (_a = this.handlers[storeKey]) === null || _a === void 0 ? void 0 : _a.handle;\n    }\n\n    shouldReuseRoute(future, current) {\n      return future.routeConfig === current.routeConfig;\n    }\n\n    getResolvedUrl(route) {\n      return route.pathFromRoot.map(v => v.url.map(segment => segment.toString()).join('/')).join('/');\n    }\n\n    getStoreKey(route) {\n      const baseUrl = this.getResolvedUrl(route);\n      const childrenParts = [];\n      let deepestChild = route;\n\n      while (deepestChild.firstChild) {\n        deepestChild = deepestChild.firstChild;\n        childrenParts.push(deepestChild.url.join('/'));\n      }\n\n      return baseUrl + '////' + childrenParts.join('/');\n    } // true if by marking the route with shouldDetach:true\n\n\n    isDetachable(route) {\n      var _a, _b;\n\n      if ((_b = (_a = route === null || route === void 0 ? void 0 : route.routeConfig) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.shouldDetach) {\n        return true;\n      }\n\n      return false;\n    }\n\n    isAtachable(route, storeKey) {\n      var _a;\n\n      if (this.isDetachable(route) && ((_a = this.handlers[storeKey]) === null || _a === void 0 ? void 0 : _a.handle)) {\n        return true;\n      }\n\n      return false;\n    }\n    /*\n    When the user goes back (attach a root)\n    */\n\n\n    clearNewerHandlerOnAttach(storeTime) {\n      const handlerKeys = Object.keys(this.handlers);\n      handlerKeys.forEach(k => {\n        if (this.handlers[k].storeTime > storeTime) {\n          const componentRef = this.handlers[k].handle.componentRef;\n\n          if (componentRef) {\n            componentRef.destroy();\n          }\n\n          delete this.handlers[k];\n        }\n      });\n    }\n\n  }\n\n  CustomRouteReuseStrategy.ɵfac = function CustomRouteReuseStrategy_Factory(t) {\n    return new (t || CustomRouteReuseStrategy)();\n  };\n\n  CustomRouteReuseStrategy.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CustomRouteReuseStrategy,\n    factory: CustomRouteReuseStrategy.ɵfac\n  });\n  return CustomRouteReuseStrategy;\n})();","map":null,"metadata":{},"sourceType":"module"}